# Emily's underlying principles

*In no particular order*

## I am not important

Users or at least library authors should be able to do the unthinkable: Participate in generation of error messages. Maybe someday optimization passes?

### I trust you

## Minimize the number of concepts

## "Anything a code generator can do", in-language

### One language

As opposed to one language for code, plus one language for templates, plus one language for macros, plus one language for build scripts...

### Define objects by their behavior, not their nature

## DRY/SWYM

Destroy all boilerplate

Destroy all idiomatic code

You should not have to be continously trying to remember "how to do it" (, ; space)

Computers are good at repetitive, non-executive tasks and bad at decisionmaking. Humans are good at decisionmaking and bad at repetitive tasks. If there is something such that "you have to do it every time", it is something the computer could and should be doing.

## No parser

### Types determine what is possible

## Privilege ease over correctness

Programming should be easy. Programming should be egaltarian.

Words are better than symbols.

Words are better than dvwlld grbg.

### Correctness should be *possible*

## It is my job to make it hard for you to do something wrong by accident. It is not my job to make it hard for you to do something wrong on purpose.

## It should be hard to write yourself in a corner

## Don't pay for what you don't use

C++ gets this backward

## Parity of expressions and definitions

## Deployability is all-important